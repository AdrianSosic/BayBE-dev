# Example for using a synthetic BoTorch test function in a continuous searchspace

Example for using the synthetic test functions in a continuous spaces.
All test functions that are available in BoTorch are also available here and wrapped
via the `botorch_function_wrapper`.

This example assumes some basic familiarity with using BayBE.
We thus refer to [`campaign`](./../Basics/campaign.md) for a basic example.
Also, there is a large overlap with other examples with regards to using the test
function.
We thus refer to [`discrete_space`](./discrete_space.md) for details on this aspect.

## Necessary imports for this example


```python
from botorch.test_functions import Rastrigin
```


```python
from baybe import Campaign
from baybe.objectives import SingleTargetObjective
from baybe.parameters import NumericalContinuousParameter
from baybe.searchspace import SearchSpace
from baybe.targets import NumericalTarget
from baybe.utils.botorch_wrapper import botorch_function_wrapper
```

## Defining the test function

See [`discrete_space`](./../Searchspaces/discrete_space.md) for details.


```python
DIMENSION = 4
TestFunctionClass = Rastrigin
```


```python
if not hasattr(TestFunctionClass, "dim"):
    TestFunction = TestFunctionClass(dim=DIMENSION)
elif TestFunctionClass().dim == DIMENSION:
    TestFunction = TestFunctionClass()
else:
    print(
        f"\nYou choose a dimension of {DIMENSION} for the test function"
        f"{TestFunctionClass}. However, this function can only be used in "
        f"{TestFunctionClass().dim} dimension, so the provided dimension is replaced. "
        "Also, DISC_INDICES and CONT_INDICES will be re-written."
    )
    TestFunction = TestFunctionClass()
    DIMENSION = TestFunctionClass().dim
    DISC_INDICES = list(range(0, (DIMENSION + 1) // 2))
    CONT_INDICES = list(range((DIMENSION + 1) // 2, DIMENSION))
```


```python
BOUNDS = TestFunction.bounds
WRAPPED_FUNCTION = botorch_function_wrapper(test_function=TestFunction)
```

## Creating the searchspace and the objective

Since the searchspace is continuous, we use `NumericalContinuousParameter`s.
We use the data of the test function to deduce bounds and number of parameters.


```python
parameters = [
    NumericalContinuousParameter(
        name=f"x_{k+1}",
        bounds=(BOUNDS[0, k], BOUNDS[1, k]),
    )
    for k in range(DIMENSION)
]
```


```python
searchspace = SearchSpace.from_product(parameters=parameters)
objective = SingleTargetObjective(target=NumericalTarget(name="Target", mode="MIN"))
```

## Constructing the campaign and performing a recommendation


```python
campaign = Campaign(
    searchspace=searchspace,
    objective=objective,
)
```

Get a recommendation for a fixed batch size.


```python
BATCH_SIZE = 3
recommendation = campaign.recommend(batch_size=BATCH_SIZE)
```

Evaluate the test function.
Note that we need iterate through the rows of the recommendation.
Furthermore, we need to interpret the row as a list.


```python
target_values = []
for index, row in recommendation.iterrows():
    target_values.append(WRAPPED_FUNCTION(*row.to_list()))
```

We add an additional column with the calculated target values.


```python
recommendation["Target"] = target_values
```

Here, we inform the campaign about our measurement.


```python
campaign.add_measurements(recommendation)
print("\n\nRecommended experiments with measured values: ")
print(recommendation)
```

    
    
    Recommended experiments with measured values: 
            x_1       x_2       x_3       x_4      Target
    0  1.718383  3.443025  3.433742  4.523571  117.436498
    1  3.068605 -3.909414  1.805885  4.537116   77.327429
    2 -4.091272  4.546479 -1.919157 -0.788021   71.785821

